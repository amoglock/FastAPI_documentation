<h3>Зависимости</h3>

FastAPI имеет очень мощную, но понятную систему внедрения зависимости.

Она разработана, чтобы быть очень простой в использовании и делать ее очень легкой для любого разработчика, чтобы внедрять
другие компоненты с FastAPI.

<h4>Что такое "Внедрение зависимости"</h4>

"Внедрение зависимости" означает в программировании, что существует способ для вашего кода (в нашем случае, функция 
операции пути), чтобы объявить вещи, которые требуются для работы и использования: "зависимости".

А затем, эта система (в нашем случае FastAPI) позаботится, чтобы сделать все, что требуется, чтобы обеспечить ваш код 
этими нужными зависимостями ("внедрение" зависимостей).

Это очень полезно когда вам требуется:

* Иметь общую логику (одна и та же логика кода снова и снова).
* Общий доступ подключениям к базе данных.
* Обеспечивать безопасность, аутентификацию, требования роли и т.д.
* И многое другое...

Все это, сводя к минимуму повторение кода.

<h4>Первые шаги</h4>

Давайте рассмотрим очень простой пример. Он будет таким простым, что не очень полезным, пока что.

Но таким образом мы можем сосредоточиться на том, как работает система внедрения зависимостей.

<h5>Создание зависимости</h5>

Давайте, сперва, сфокусируемся на зависимости.

Это просто функция которая может принимать все те же самые параметры, как может принимать функция операции пути:

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()

async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

Вот и все.

Две строки.

И они имеют ту же структуру и форму, как и все ваши функции операции пути.

Вы можете думать об них как о функциях операции пути без "декоратора" (без `app.get("/some-path/")`).

А они могут возвращать все что вы хотите.

В нашем случае, эта зависимость ожидает:

* Необязательный параметр `q` в `str`.
* Необязательный параметр `skip` в `int`, со значением по умолчанию `0`.
* Необязательный параметр `limit` в `int`, со значением по умолчанию `100`.

А затем она просто возвращает `dict`, содержащий эти значения.

> **Для информации**
> 
> В FastAPI добавилась поддержка `Annotated` (и стала рекомендованной) в версии 0.95.0.
> 
> Если у вас более старая версия, вы можете получать ошибки, пытаясь использовать `Annotated`.
> 
> Убедитесь, что вы
> <a href="https://fastapi.tiangolo.com/deployment/versions/#upgrading-the-fastapi-versions">Обновили версию FastAPI</a>
> не ниже 0.95.1, перед использованием `Annotated`.

<h5>Импорт `Depends`</h5>

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

<h5>Объявление зависимости в "зависимом" месте</h5>

Точно так же как вы используете `Body`, `Query`, и т.д с вашими параметрами функции операции пути, используйте `Depends`
с новым параметром:

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

Хотя, вы используете `Depends` в параметрах вашей функции точно так же как используете `Body`, `Query`, и т.д, `Depends`
работает чуть иначе.

Вы передаете `Depends` один параметр.

Этот параметр должен быть чем-то вроде функции.

Вы не вызываете ее напрямую (не добавляете скобки в конце), просто передаете ее как параметр в `Depends()`.

И эта функция принимает параметры точно так же как это делает функция операции пути.

> **Подсказка**
> 
> Вы увидите, что и другие "штуки", отдельно от функций, могут использоваться как зависимости в следующей главе.

Всякий раз когда приходит новый запрос, FastAPI позаботится:

* Об вызове вашей зависимости ("зависимой") функции с правильными параметрами.
* Получит результат из вашей функции.
* Об присвоении этого результата параметру в вашей функции операции пути.

Таким образом вы пишете общий код один раз, а FastAPI берет на себя его вызов в ваших операциях пути.

> **Для галочки**
> 
> Обратите внимание, что вам не нужно создавать специальный класс и где-то передавать его в FastAPI на "регистрацию" или
> что-то похожее.
> 
> Вы просто передаете его в `Depends`, а FastAPI знает, что с ним делать в итоге.