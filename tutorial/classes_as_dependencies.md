<h3>Классы как зависимости</h3>

Перед более глубоким погружением в системы внедрения зависимостей, давайте обновим предыдущий пример.

<h4>`dict` из предыдущего примера</h4>

В прошлом примере мы возвращаем `dict` из нашей зависимости ("зависимого"):

```python
from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}

@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

Но затем мы получаем `dict` в параметре `commons` функции операции пути.

А мы знаем, что редакторы не могут предоставить много поддержки (например завершение) для словарей, потому, что они 
(редакторы) не знают типов ключей и значений.

Мы можем сделать лучше...

<h4>Что делает зависимость</h4>

До сих пор вы видели зависимости, объявленные как функции.

Но это не единственный способ объявить зависимости (хотя он был бы, вероятно, более частым).

Ключевой фактор это, то что зависимость должна быть "callable".

"Callable" в Python это что-то, что Python может "вызывать" как функцию.

Поэтому, если у вас есть объект `something` (который может не быть функцией) и вы можете "вызывать" его (выполнять):

```python
something()
```

или 

```python
something(some_argument, some_keyword_argument="foo")
```

Тогда это и есть "callable".

<h4>Классы как зависимости</h4>

Вы можете обратить внимание, чтобы создать экземпляр класса Python, вы используете одинаковый синтаксис.

Например:

```python
class Cat:
    def __init__(self, name: str):
        self.name = name

fluffy = Cat(name="Mr Fluffy")
```

В этом случае, `fluffy` это экземпляр класса `Cat`.

А чтобы создать `fluffy`, вы "вызываете" `Cat`.

Поэтому, класс Python - тоже callable.

Тогда, в FastAPI, вы можете использовать класс Python как зависимость.

Что на самом деле проверяет FastAPI, это то, что это "callable" (функция, класс или что-то еще) и объявленные параметры.

Если вы передаете "callable" как зависимость в FastAPI, он будет анализировать параметры для этого "callable", и обрабатывать
их точно так же как параметры для функции операции пути. Включая подзависимости.

Это также относится к вызываемым объектам вообще без параметров. То же самое, что было бы для функций операции пути 
без параметров.


