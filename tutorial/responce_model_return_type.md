<h3>Модель ответа - возвращаемый тип</h3>

Вы можете объявлять какой тип использовать для ответа, с помощью аннотации возвращаемого типа функции операции пути.

Вы можете использовать аннотации типа таким же способом как для входных данных в параметрах функции, вы можете использовать
модели Pydantic, списки, словари, скалярные значения вроде чисел, логические типы и т.д.

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []

@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item

@app.get("/items/")
async def read_items() -> list[Item]:
    return [
        Item(name="Portal Gun", price=42.0),
        Item(name="Plumbus", price=32.0),
    ]
```

FastAPI будет использовать этот тип возвращаемых данных для:

* Проверки возвращаемых данных.
  * Если данные недопустимы (например вы пропустили поле), это значит, что работа вашего приложения нарушена, не возвращает,
    то что следовало бы, и оно вернет ошибку сервера вместо возвращения некорректных данных. Таким способом вы и ваши клиенты
    могут быть уверены, что они будут получать данные и в ожидаемой форме.
* Добавления схемы JSON для ответа в операции пути OpenAPI.
  * Это будет использоваться для автоматической документации.
  * Она также будет использоваться инструментами автоматической генерации клиентского кода.

Но самое важное:
* Будет ограничивать и фильтровать выходные данные к тому, что установлено в возвращаемом типе.
  * Это особенно важно для безопасности, мы увидим больше об этом ниже.   

<h3>Параметр `response_model`</h3>

Существуют некоторые случаи где вам нужно, или вы хотите возвращать некие данные, которые не совсем то, что заявлено в типе.

Например, вы могли бы захотеть вернуть словарь или объект базы данных, но объявляете его как модель Pydantic. Таким способом
модель Pydantic делала бы всю документацию данных, проверку, и т.д. для объекта который вы вернули (например, словарь
или объект базы данных).

Если вы добавили аннотацию возвращаемого типа, инструменты и редакторы жаловались бы (правильной) ошибкой, говоря вам, что 
ваша функция возвращает тип (например словарь) которые отличается от того, что вы объявили (например модель Pydantic).

И таких случаях, вы можете использовать параметр декоратора операции пути `response_model` вместо типа возврата.

Вы можете использовать параметр `response_model` в любых операциях пути:

* `@app.get()`
* `@app.post()`
* `@app.put()`
* `@app.delete()`
* и т.д.

```python
from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []

@app.post("/items/", response_model=list[Item])
async def read_items() -> Any:
    return [
      {"name": "Portal Gun", "price": 42.0},
      {"name": "Plumbus", "price": 32.0},
    ]
```

> **Заметка**
> 
> Обратите внимание, что `response_model` это параметр метода "декоратора" (`get`, `post` и т.д.). А не вашей функции
> операции пути, как все параметры и тело.

`response_model` получает тот же тип который вы бы объявили для поля модели Pydantic, поэтому, он может быть моделью
Pydantic, но он может также быть, например, `list` или моделями Pydantic, как `List[Item]`.

FastAPI будет использовать эту `response_model` чтобы делать всю документацию, проверку, и т.д. и еще, чтобы конвертировать
и фильтровать выходные данные в объявленный тип.

> **Совет**
> 
> Если у вас есть строгие проверки типов в вашем редакторе, mypy, и т.д., вы можете объявлять тип возврата функции как `Any`.
> 
> Этим способом вы говорите редактору, что вы специально возвращаете "что угодно". Но FastAPI все равно будет делать
> документацию, проверку, фильтрацию и т.д. с помощью `response_model`.

<h3>Приоритет `response_model`</h3>

Если вы объявляете и тип возврата, и `response_model`, `response_model` будет иметь приоритет и использоваться FastAPI.

Таким способом вы можете добавлять правильные аннотации типов вашим функциям, даже когда вы возвращаете тип, отличающийся
от модели ответа, чтобы он был использован в редакторе и инструментах вроде mypy. А у вас FastAPI все еще делает проверку
данных, документацию, и т.д., используя `response_model`.

Вы также можете использовать `response_model=None` чтобы отключить создание модели ответа для операции пути, вам, возможно,
потребуется сделать это если вы добавляете аннотации типов для того, что не подходит полям Pydantic, вы увидите такой пример
в одной из секций ниже.

<h3>Возврат одних и тех же входных данных</h3>

Здесь мы объявляем модель `UserIn`, она будет содержать незашифрованный пароль:

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()

class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None
...
```

> **Для информации**
> 
> Чтобы использовать `EmailStr`, сперва установите <a href="https://github.com/JoshData/python-email-validator">`email_validator`</a>.
> 
> Например `pip install email-validator` или `pip install pydantic[email]`.

И мы используем эту модель, чтобы объявить наши входящие данные и ту же модель для выходящих:

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()

class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None

# Не делайте так в настоящей разработке!
@app.post("/user/")
async def create_user(user: UserIn) -> UserIn:
    return user
```

Теперь, всякий раз когда браузер создает пользователя с паролем, API будет возвращать пароль в ответе.

В этом случае это может не быть проблемой, так как пароль отправляет тот же пользователь.

Но если мы используем ту же модель для других операций пути, мы бы отправляли пароли наших пользователей каждому клиенту.

> **Опасность**
> 
> Никогда не храните незашифрованный пароль пользователя или не отправляйте его в ответе как здесь, если только вы 
> не знаете всех предупреждений и вы знаете, что делаете. 

<h3>Добавление модели вывода</h3>

Вместо этого, мы можем создать модель с незашифрованным паролем для входящих данных и модель для выходящих без него:

```python
from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None

class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None
...
```

Здесь, даже если наша функция операции пути возвращает того же пользователя, содержащего пароль, что и на входе:

```python
from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None

class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None

@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user
```

Мы объявили, чтобы `response_model` была нашей моделью `UserOut`, которая не включает в себя пароль:

```python
@app.post("/user/", response_model=UserOut)
```

Поэтому, FastAPI позаботится о фильтрации всех данных, которые не объявлены в модели вывода (используя Pydantic).

<h3>`response_model` или возвращаемый тип</h3>

В таком случае, так как две модели отличаются, если мы обозначили тип возврата функции как `UserOut`, редактор и
инструменты жаловались бы, что мы возвращаем неподходящий тип, поскольку это разные классы.

Вот почему в примере нам нужно объявлять его в параметре `response_model`.

...но продолжайте читать дальше, чтобы узнать как обойти это.

<h3>Тип возврата и фильтрация данных</h3>

Давайте продолжим с предыдущего примера. Мы хотели описать функцию с одним типом, а возвращать что-то, что включает
больше данных.

Мы хотим чтобы FastAPI продолжал фильтровать данные, используя модель ответа.

В предыдущем примере, так как классы отличались, нам нужно было использовать параметр `response_model`. Но, это так же
означает, что мы не получаем поддержку от редактора и инструментов проверки типа возвращаемого функцией.

Но в большинстве случаев, где нам нужно сделать что-то типа этого, мы хотим чтобы модель просто фильтровала/удаляла 
какие-то данные, как в примере.

И в таких случаях мы можем использовать классы и наследование, чтобы воспользоваться преимуществами аннотаций типов 
функции, чтобы получить лучшую поддержку в редакторе и инструментах, и все еще получать фильтрацию данных FastAPI.

```python
from fastapi import FastApi()
from pydantic import BaseModel, EmailStr

app = FastApi()

class BaseUser(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None

class UserIn(BaseUser):
    password: str

@app.post("/user/")
async def create_user(user: UserIn) -> BaseUser:
    return user
```

Вот так мы получаем поддержку инструментов от редакторов и mypy, так как этот код правильный в условиях типов, но мы
также получаем фильтрацию данных от FastAPI.

Как это работает? Давайте это выясним.🤓

