# Oauth2 с паролем (и хешированием), Bearer с JWT токенами

Теперь, когда у нас есть весь поток безопасности, давайте сделаем приложение безопасным на самом деле, используя JWT токены
и безопасное хеширование пароля.

Этот код - что-то такое, что вы можете на самом деле использовать в вашем приложении, хранить хеши паролей в базе данных, 
и т.д.

Мы собираемся начать оттуда, где мы остановились в предыдущей главе и нарастить его.

## Про JWT

JWT означает "JSON Web Tokens".

Это стандарт, чтобы кодировать объект JSON в длинную, непонятную строку без пробелов. Она может выглядеть так:

> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxw
> RJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

Она не зашифрована, поэтому, любой мог бы восстановить информацию из содержимого.

Но она подписана. Поэтому, когда вы получаете токен который вы отправили, можно проверить, что его отправили именно вы.

Таким образом, вы можете создать токен со сроком действия, скажем, неделя. А затем когда пользователь возвращается на 
следующий день с этим токеном, вы знаете, что пользователь все еще залогинен в вашей системе.

По прошествии недели, токен будет просрочен и пользователь не будет авторизован и будет нужно войти снова, чтобы получить
новы токен. И если пользователь (или третье лицо) пытался поменять токен, чтобы изменить срок истечения, вы бы смогли
это заметить, так как подписи уже не совпадали.

Если хотите "поиграть" с JWT токенами и посмотреть как они работают, посмотрите https://jwt.io.

## Установка `python-jose`

Нам нужно установить `python-jose`, чтобы создавать и проверять JWT токены в Python:

```commandline
pip install "python-jose[cryptography]"
```

<a href="https://github.com/mpdavis/python-jose">Python-jose</a> требует криптографический бекенд как дополнительный.

Здесь мы используем рекомендованный: <a href="https://cryptography.io/">pyca/cryptography</a>.

> **Подсказка**
> 
> Эта инструкция ранее использовала <a href="https://pyjwt.readthedocs.io/">PyJWT</a>.
> 
> Но он был изменен для использования Python-jose, так как он предоставляет преимущества из PyJWT плюс некоторые 
> дополнения, которые могут вам понадобиться позже при постройке интеграций с другими инструментами.

## Хеширование пароля

"Хеширование" означает конвертацию какого-то содержимого (пароль в нашем случае) в последовательность байтов (просто 
строка), которая выглядит как бессмыслица.

Каждый раз когда вы передаете одно и то же содержимое (один и тот же пароль) вы получаете одну и ту же "бессмыслицу".

Но вы не можете конвертировать "бессмыслицу" обратно в пароль.

### Зачем использовать хеширование пароля

Если ваша база данных украдена, вор не сможет получить незашифрованные пароли ваших пользователей, только хеши.

Поэтому, вор не сможет использовать эти пароли в других системах (так как многие пользователи используют одинаковые
пароли везде, это может быть опасно).

## Установка `passlib`

Passlib отличный пакет Python, чтобы обрабатывать хеши паролей.

Он поддерживает много безопасных алгоритмов хеширования и утилит для работы с ними.

Рекомендованный алгоритм это "Bcrypt".

Поэтому, установим PassLib с Bcrypt:

```commandline
pip install "passlib[bcrypt]"
```

> **Совет**
> 
> С `passlib` вы можете даже настроить его, чтобы читать пароли, созданные с помощью **Django**, **Flask** или многих других.
> 
> Поэтому, вы могли бы, например, обмениваться одними данными из приложения Django в базу данных приложения FastAPI. Или
> постепенно перенести приложение Django, используя ту же базу данных.
> 
> А ваши пользователи могли бы войти из вашего приложения Django или приложения FastAPI одновременно.

## Хеш и проверка паролей

Импортируйте нужные нам инструменты из `passlib`.

Создайте PassLib "контекст". Это то, что будет использовано для хеширования и проверки паролей.

> **Совет**
> 
> Контекст PassLib также имеет функциональность, чтобы использовать различные алгоритмы хеширования, включая устаревшие, 
> только, чтобы предоставить их проверку, и т.д.
> 
> Например, вы можете использовать его, чтобы прочитать и проверить пароли, сгенерированные другими системами (например
> Django), а хешировать любые новые пароли другим алгоритмом, например, Bcrypt.
> 
> И быть совместимым со всем этим одновременно.

