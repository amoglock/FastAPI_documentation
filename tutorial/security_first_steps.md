<h3>Безопасность - первые шаги</h3>

Давайте представим, что у вас есть бэкенд вашего API на каком-то домене.

И есть фронтенд на другом домене или отдельном пути того же домена (или в мобильном приложении).

И вы хотите иметь способ во фронтенде для аутентификации с бэкендом, используя имя пользователя и пароль.

Мы можем использовать OAuth2, чтобы сделать это с FastAPI.

Но давайте сбережем вам время прочтения всей длинной спецификации, просто для того, чтобы найти маленькие частички 
информации которая вам нужна.

Давайте использовать инструменты предоставленные FastAPI, чтобы обрабатывать безопасность.

<h4>Как это выглядит</h4>

Давайте сперва просто использовать код и посмотрим как он работает, а затем вернемся, чтобы понять, что происходит.

<h4>Создайте `main.py`</h4>

Скопируйте пример в файл `main.py`:

```python
from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"token": token}
```

<h4>Запустим это</h4>

> **Для информации**
> 
> Сперва установите <a href="https://andrew-d.github.io/python-multipart/">`python-multipart`</a>.
> 
> Например `pip install python-mulptipart`.
> 
> Это потому, что OAuth2 использует "данные формы" для отправки `username` и `password`.

Запустите пример:

```commandline
uvicorn main:app --reload
```

<h4>Проверьте</h4>

Перейдите в интерактивную документацию: <a href="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a>.

Вы увидите что-то вроде этого:

<img src="https://fastapi.tiangolo.com/img/tutorial/security/image01.png">

> **Кнопка авторизации!**
> 
> У вас уже есть новая, блестящая кнопка "Authorize".
> 
> А у вашей операции пути есть маленький замок в правом верхнем углу, который вы можете кликнуть.

И если вы его нажмете, у вас есть небольшая форма авторизации, чтобы ввести `username` и `password` (и другие 
дополнительные поля):

<img src="https://fastapi.tiangolo.com/img/tutorial/security/image02.png">

> **Заметка**
> 
> Не важно, что вы напечатаете в форме, она пока не будет работать. Но мы доберемся и туда.

Это, конечно, не фронтенд для конечных пользователей, но это отличный автоматический инструмент, чтобы интерактивно 
документировать весь ваш API.

Он может быть использовать командой фронтенда (которая может быть вами же).

Она может быть использована сторонними приложениями и системами.

И она может быть использована вами же, для отладки, проверки и тестирования того же приложения.

<h4>The `password` flow</h4>

Теперь давайте вернемся чуть назад и поймем, что это все такое.

`Password` "flow" это один из способов ("flows") определенных в OAuth2, чтобы обрабатывать безопасность и аутентификацию.

OAuth2 был разработан так, что бэкенд или API могут быть независимыми от сервера, который аутентифицирует пользователя.

Но в таком случае, то же FastAPI приложение будет обрабатывать API и аутентификацию.

Поэтому, давайте рассмотрим его с упрощенной точки зрения:

* Пользователь набирает `username` и `password` в фронтенде и жмет `Enter`.
* Фронт (запущенный в браузере пользователя) отправляет эти `username` и `password` на определенный URL в нашем API
(объявленный с `tokenURL="token"`).
* API проверяет эти `username` и `password`, и отвечает на "token" (пока мы ничего из этого не реализовали).
  * "Token" это просто строка с каким-то содержимым, которое мы можем использовать позже для того, чтобы верифицировать
  этого пользователя.
  * Обычно, токен устанавливается так, чтобы он истекал через какое-то время.
    * Поэтому, позже пользователю нужно будет войти снова в какой-то момент.
    * А если токен украден, риск меньше. Это не постоянный ключ, который будет работать вечно (в большинстве случаев).
* Фронтенд где-то временно хранит этот токен.
* Пользователь нажимает в интерфейсе, чтобы перейти в другой раздел интерфейса веб-приложения.
* Фронтенду нужно получить еще некоторые данные из API.
  * Но ему нужна аутентификация для определенного эндпоинта.
  * Поэтому, чтобы аутентифицироваться с нашим API, он отправляет заголовок `Authorization` со значением `Bearer` плюс токен.
  * Если токен содержит `foobar`, содержимое заголовка `Authorization` было бы: `Bearer foobar`.

<h4>`OAuth2PasswordBearer` FastAPI</h4>

FastAPI предоставляет несколько инструментов различных уровней абстракции, чтобы реализовать эти возможности безопасности.

В этом примере мы будем использовать **OAuth2** с потоком **Password**, используя токен **Bearer**. Мы делаем это, 
используя класс `OAuth2PasswordBearer`.

> **Для информации**
> 
> Токен "bearer" не единственная опция.
> 
> Но он лучший для нашего случая.
> 
> И он может быть лучшим для многих случаев использования, если только вы не эксперт в OAuth2, и точно знаете почему
> есть другой вариант, который лучше соответствует вашим потребностям.
> 
> В этом случае FastAPI также предоставляет вам инструменты, чтобы создать его.

Когда мы создаем экземпляр класса `OAuth2PasswordBearer`, мы передаем `tokenUrl` в параметре. Этот параметр содержит URL,
который, клиент (фронт, запущенный в браузере пользователя) использует, чтобы отправить `username` и `password` для того
чтобы получить токен.

```python
from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

...
```

> **Совет**
> 
> Здесь `tokenUrl="token"` ссылается на относительный URL `token`, который у нас пока не создан. Так как это 
> относительный URL, он будет эквивалентен `./token`.
> 
> Так как мы используем относительный URL, если ваш API расположен на `https://example.com/`, то он будет ссылаться
> на `https://example.com/token`. Но если ваш API расположен на `https://example.com/api/v1/`, то он будет ссылаться на
> `https://example.com/api/v1/token`.
> 
> Использование относительных URL важно, чтобы быть уверенным, что ваше приложение продолжает работать даже в сложных
> случаях, вроде <a href="https://fastapi.tiangolo.com/advanced/behind-a-proxy/">Behind a proxy</a>.

Этот параметр не создает эндпоинт / операцию пути, но объявляет, что URL `/token` будет тем, который клиенту нужно 
использовать, чтобы получить токен. Эта информация используется в OpenAPI, а затем в системах интерактивной документации.

Скоро мы также создадим фактическую операцию пути.

> **Для информации**
> 
> Если вы очень строгий "питонист", вам может не понравиться стиль имени параметра `tokenUrl` вместо `token_url`.
> 
> Это потому, что используется то же имя, как и в спецификации OpenAPI. Так что если вам нужно разобраться больше в любой
> из этих схем безопасности, вы можете просто копировать и вставлять их, чтобы найти больше информации.

Переменная `oauth2_scheme` это экземпляр `OAuth2PasswordBearer`, но еще и "callable".

Она может быть вызвана как:

```python
oauth2_scheme(some, parameters)
```

Поэтому она может быть использована с `Depends`.

<h5>Используй это</h5>

Теперь вы можете передавать, что `oauth2_scheme` в зависимости с `Depends`.

```python
from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"token": token}
```

Эта зависимость будет предоставлять `str`, которая присвоена параметру `token` функции операции пути.

FastAPI будет знать, что он может использовать эту зависимость, чтобы определить "схему безопасности" в схеме OpenAPI
(и автоматической документации API).

> **Технические детали**
> 
> FastAPI будет знать, что он может использовать класс `OAuth2PasswordBearer` (объявленный в зависимости), чтобы определить
> схему безопасности в OpenAPI, так как он наследуется из `fastapi.security.oauth2.OAuth2`, который в свою очередь 
> наследуется от `fastapi.security.base.SecurityBase`.
> 
> Все утилиты безопасности, которые интегрируются с OpenAPI (и документацией API) наследуются от `SecurityBase`, вот 
> как FastAPI может знать как интегрировать их в OpenAPI.

<h4>Что он делает</h4>

Он пойдет и посмотрит в запросе на заголовок `Authorization`, проверит, что есть значение `Bearer` плюс какой-то токен,
и вернет токен как `str`.

Если он не видит заголовок `Authoization`, или значение не имеет токена `Bearer`, он ответит напрямую, со статус-кодом 
ошибки 401 (`UNAUTHORIZED`).

Вам даже не нужно проверять, что токен существует, чтобы вернуть ошибку. Вы можете быть уверенным, что если ваша функция 
выполняется, у нее будет `str` в этом токене.

И вы уже можете попробовать это в интерактивной документации:

<img src="https://fastapi.tiangolo.com/img/tutorial/security/image03.png">

Пока мы не проходим проверку токена, но это уже начало.

<h4>Резюме</h4>

Итак, просто за 3 или 4 строки, у вас уже есть какая-то простейшая форма безопасности.